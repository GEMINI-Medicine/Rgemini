---
title: "Data Coverage"
output:
  html_vignette:
    number_sections: true
    toc: true
    dfprint: kable

vignette: >
  %\VignetteIndexEntry{Data Coverage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 8,
  fig.height = 5,
  out.width = "75%",
  comment = "#>"
)
library(data.table)
library(dplyr)
library(lemon)
library(ggplot2)
library(Rgemini)
library(lubridate)
#setwd("~/GitHub/Rgemini/vignettes/")
```

*  *  *  *

# Introduction

The `data_coverage()` function facilitates commonly performed data coverage checks and is meant as a **starting point** for data coverage exploration.

Although GEMINI aims to achieve high coverage of all data elements, it's possible that some tables could not be fully extracted from certain hospitals/time periods. This is especially true for clinical variables, such as lab, transfusion, radiology, or pharmacy data.

Therefore, one of the first steps of any analysis with GEMINI data should be to carefully check data coverage for all relevant tables. Depending on the research question, this may inform study feasibility, cohort creation, decisions about imputation of missing values, and/or modelling choices. 

<details>
<summary>**Expand this section for an example**</summary>

If the goal of a project is to compare patients who received a blood transfusion vs. those who did not, researchers first need to check data coverage for the transfusion table. In this scenario, users cannot simply check whether a given `genc_id` has an entry in the transfusion table because there are 2 possible reasons for why a `genc_id` might not exist in the transfusion table:

1. ***Clinical reason:*** A transfusion may not have been indicated (i.e., the patient did indeed not receive a transfusion).
2. ***Data coverage issue:*** The patient did receive a blood transfusion, but the GEMINI transfusion table does not contain the corresponding `genc_id` due to data coverage issues (e.g., data extraction issue).

We need to be able to differentiate between these 2 scenarios to distinguish:

1. ***True negatives:*** I.e., patient did indeed not receive an RBC transfusion, so we can set `transfused` to `FALSE`.
2. ***Transfusion status unknown:*** I.e., we do not have any data to know whether the patient received a transfusion, so we should set `transfused` to `NA` (or exclude patients without transfusion coverage from the cohort).

Additionally, if the goal is to analyze differences in transfusion practices across hospitals, we also need to check whether there are differences in data coverage timelines across sites. For example, if some hospitals only have transfusion data *before* 2020, whereas other hospitals only have transfusion data *after* 2020, any between-hospital differences we observe may in fact be driven by changes in transfusion practices over time (rather than reflecting true differences between hospitals). We therefore need to carefully consider which hospitals & time periods to include in our analyses, and how to account for differences in data coverage periods in our analyses.

</details>
<br></br>

This vignette focuses on data coverage checks at the level of **tables** - not individual columns within a given table. This is because table-level data coverage is typically more challenging to analyze and requires a thorough inspection and understanding of the GEMINI cohort. By contrast, column-level missingness within a single table can easily be checked using [`Rgemini::n_missing()`](https://gemini-medicine.github.io/Rgemini/reference/n_missing.html). Column-level missingness should typically follow the table-level coverage checks discussed here. 

<br></br><br></br>

# Data coverage lookup table
 
The `data_coverage()` function queries the `lookup_data_coverage` table, which lists the time periods with coverage for each data table and hospital (also see Data Availability plot in the [Data Dictionary](https://geminimedicine.ca/the-gemini-database/)). The min/max dates refer to the range of **discharge dates** (from `admdad`) with data coverage:

```{r eval = FALSE}
lookup_data_coverage <- dbGetQuery(
  db, "SELECT * from lookup_data_coverage;"
) %>% data.table()
```

> This is an example (dummy version) of the `lookup_data_coverage` table showing the min-max coverage dates for different hospital*data combinations:

```{r echo = FALSE, results = 'asis'}
lookup_data_coverage <- data.table(
  data = c("admdad", "pharmacy", "lab", "radiology", "transfusion", "ipscu", "ipdiagnosis", "er", "physicians"),
  hospital_num = c(1, 2, 3, 4, 5, 6, 7, 8, 9),
  hospital_id = c("GRH", "LHSCU", "LHSCV", "HHCO", "HHSH", "HHSJ", "HRH", "PMH", "MKHR"), # just adding this to ensure consistency with plots created below (based on hospital_id)
  min_date = c("2018-02-01", "2018-10-01", "2019-07-01", "2017-01-01", "2015-04-01", "", "2015-04-01", "", "2016-04-01"),
  max_date = c("2023-03-31", "2023-06-30", "2023-03-31", "2023-06-30", "2022-05-31", "", "2023-06-30", "", "2023-03-31"),
  additional_info = c("Hospital opened in February 2018.", "", "", "", "", "Hospital does not have an ICU.", "", "Hospital provides specialized care and does not have an ICU.", "")
)
lookup_data_coverage[, min_date := as.Date(min_date)]
lookup_data_coverage[, max_date := as.Date(max_date)]

cat("<div style='font-size: 10px;'>")
lookup_data_coverage[, -c("hospital_id")] %>%
  knitr::kable(format = "html", escape = TRUE, align = c("c", "c", "c", "c", "c"))
cat("</div>")
```

<br></br>

**Note:**

- The min/max dates in each row correspond to the start/end date of a single data coverage period by hospital*table.
- Gaps in data coverage are defined as a period of > 28 days without any data.
- Encounters with a discharge date within the listed min-max periods are assumed to have ***at least some*** data coverage for that table.
- The `additional_info` column contains information that may be helpful when interpreting the output of the `data_coverage` function.

<br></br>

<strong style="color:red;">WARNING: </strong>
**Our threshold for data coverage is currently extremely low!** We assume that there is **some** data coverage if there is **at least 1 `genc_id`** with an entry in a given table during a 28-day period. It does not tell us how high data coverage actually is (e.g., was there only 1 `genc_id` or 1,000 `genc_ids` with an entry in a given table?). Hence, when filtering by the min/max dates in the `lookup_data_coverage` table, we are simply excluding time periods without ANY data at all. Therefore, users should only use this lookup table as a starting point for data coverage exploration. For a more detailed discussion on how to check the % data coverage, please review the section on [`plot_coverage`](#plot_coverage) below. 


<br></br><br></br>

# How to use `data_coverage()`

## Get encounter-level coverage flag (without plots)

The `data_coverage()` function converts the `lookup_data_coverage` table to an encounter-level table. Let’s say we want to check which encounters in our cohort of interest were discharged during time periods with `lab`, `transfusion`, and `radiology` data coverage:

```{r eval = FALSE}
# Get encounter-level coverage flags
coverage <- data_coverage(
  db, cohort, table = c("lab", "transfusion", "radiology"),
  plot_timeline = FALSE, plot_coverage = FALSE
)
```

> This is an example (dummy version) of the ouput table returned by `data_coverage()`:

```{r echo = FALSE, results = 'asis'}
coverage <- data.table(
  genc_id = c(1, 2, 3, 4, 5, 6, 7, 8, 9),
  hospital = c(1, 2, 3, 4, 5, 6, 7, 8, 9),
  discharge_date = c("2022-08-12", "2020-12-05", "2019-04-25", "2018-03-30", "2019-07-15", "2021-09-27", "2016-04-03", "2021-11-07", "2023-01-28"),
  lab = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE),
  transfusion = c(FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE),
  radiology = c(TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE)
)

cat("<div style='font-size: 10px;'>")
coverage %>%
  knitr::kable(format = "html", escape = TRUE, align = c("c", "c", "c", "c", "c"))
cat("</div>")
```

<br></br>

The table contains a flag for each `genc_id` indicating whether that `genc_id` was discharged from a hospital & during a time period where ANY lab/transfusion/radiology data were available (based on the min-max dates in the lookup table). 

**Note:** This does *not* mean that all `genc_ids` where the flag is `TRUE` have an entry in the lab/transfusion/radiology table (e.g., not all encounters receive a transfusion). It simply means that for `genc_ids` where the flag is `TRUE`, we can now perform additional analyses of the lab/transfusion/radiology table (e.g., to derive whether or not the encounter received a transfusion). By contrast, for `genc_ids` where the flag is `FALSE`, we do not have sufficient data coverage to infer whether the encounter received a lab/imaging test or transfusion. Therefore, these `genc_ids` should be excluded (or set to `NA`) for any analyses relying on lab/transfusion/radiology data.

<br></br>

## Plot data timelines by table & hospital

To plot the data timelines by hospital & table, you can set the `plot_timeline` input to `TRUE`, which will result in a plot similar to the “Data Availability” plot in the data dictionary.

However, the plot returned by this function is customized to the input cohort (e.g., time periods/hospitals of interest) and specific tables that are relevant for your analyses.

For example, let's say we are interested in the data timelines for the `admdad`, `lab`, and `ipscu` table for encounters discharged since April 2017:

```{r include = FALSE, eval = FALSE}
library(DBI)
library(RPostgreSQL)
library(getPass)
library(lubridate)
library(ggplot2)

# create plot and save image for vignette
drv <- dbDriver("PostgreSQL")
dbcon <- DBI::dbConnect(drv,
  dbname = "drm_cleandb_v3_1_0", # "drm_cleandb_v2_1_3", "drm_cleandb_v3_1_0", "report_db_v3",
  host = "prime.smh.gemini-hpc.ca",
  port = 5432,
  user = "lofflera",
  password = getPass("Enter Password:")
)
cohort <- dbGetQuery(dbcon, "SELECT genc_id, discharge_date_time, hospital_id FROM admdad WHERE discharge_date_time >= '2017-04-01 00:00';") %>% data.table()

# assign hosp num from 1-X
cohort[, hosp := lookup_data_coverage[.SD, hospital_num, on = "hospital_id"]]
cohort[, hosp := factor(hosp, levels = unique(sort(cohort$hosp)))]
cohort <- cohort[as.numeric(hosp) <= 9]
# cohort[, .(hospital_id, hosp)] %>% distinct()

# append additional rows to ensure consistency with dummy lookup coverage above & internally valid (e.g., lab coverage can't be longer than admdad etc.)
custom_dates <- data.table(
  data = c("lab", "ipscu", "admdad", "ipscu", "lab", "lab", "lab", "admdad", "ipscu", "lab"),
  hospital_num = c(1, 1, 8, 8, 8, 8, 8, 9, 9, 9),
  hospital_id = c("GRH", "GRH", "PMH", "PMH", "PMH", "PMH", "PMH", "MKHR", "MKHR", "MKHR"),
  min_date = c("2018-02-01", "2018-02-01", "2015-04-01", "", "2017-09-01", "2018-06-01", "2022-04-01", "2015-04-01", "2015-04-01", "2020-04-01"),
  max_date = c("2023-03-31", "2023-03-31", "2023-03-31", "", "2018-03-31", "2021-10-15", "2023-01-31", "2023-03-31", "2023-03-31", "2023-03-31")
)
custom_dates[, min_date := as.Date(min_date)]
custom_dates[, max_date := as.Date(max_date)]

custom_dates <- rbind(lookup_data_coverage, custom_dates, fill = TRUE)

# adjust path according to your Rgemini folder
source("~/GitHub/Rgemini/R/data_coverage.R") 
source("~/GitHub/Rgemini/R/utils.R")
source("~/GitHub/Rgemini/R/plot_over_time.R")

##############################
## for timeline_plot example
coverage <- data_coverage(
  dbcon, cohort, c("admdad", "ipscu", "lab"),
  plot_timeline = TRUE, plot_coverage = FALSE,
  custom_dates = custom_dates,
  hospital_label = "hosp"
)

# rename columns for output shown below
coverage$timeline_data$hospital_num <- NULL
setnames(coverage$timeline_data, "hospital", "hospital_num")
coverage$timeline_data <- coverage$timeline_data[order(hospital_num)]

coverage$coverage_flag_enc$hospital_id <- NULL
setnames(coverage$coverage_flag_enc, "hosp", "hospital_num")
coverage$coverage_flag_enc <- coverage$coverage_flag_enc[seq_len(nrow(coverage$coverage_flag_enc)) < 20 & admdad == TRUE]
coverage$coverage_flag_enc[, genc_id := 1:length(unique(genc_id))]


##############################
## for coverage_plot example
cohort <- cohort[hospital_id != "GRH" | (hospital_id == "GRH" & discharge_date_time > "2018-02-01")]
# remove some genc_ids with transfusions from site 7 to imitate coverage drop
transf <- dbGetQuery(dbcon, "SELECT genc_id FROM transfusion WHERE hospital_id = 'HRH';") %>%
  data.table()
cohort[, excl := hospital_id == "HRH" & genc_id %in% transf$genc_id &
((discharge_date_time > "2019-01-07" & discharge_date_time < "2019-02-10") |
(discharge_date_time > "2019-02-20" & discharge_date_time < "2019-03-15") | 
(discharge_date_time > "2019-03-20" & discharge_date_time < "2019-04-05"))]
cohort <- cohort[excl == FALSE, ]

# remove some genc_ids with transfusions from site 8 to imitate overall low coverage
transf <- dbGetQuery(dbcon, "SELECT genc_id FROM transfusion WHERE hospital_id = 'PMH';") %>%
  data.table()
set.seed(99)
transf <- transf[sample(nrow(transf), 0.9 * nrow(transf))]
cohort[, excl := genc_id %in% transf$genc_id | (hospital_id == "PMH" & discharge_date_time >= "2020-04-01 00:00" & discharge_date_time < "2020-06-15 00:00")]
cohort <- cohort[excl == FALSE, ]
# append encounters on both sites to mimic overall data availabilty of admdad
append <- seq(
  from = as.Date("2017-04-01 00:00"),
  to = as.Date("2023-03-01 00:00"),
  by = "month"
)

cohort <- rbind(cohort, data.table(
  discharge_date_time = as.character(append),
  genc_id = 1:length(append),
  hosp = rep(8, length(append)),
  hospital_id = rep("PMH", length(append)),
  excl = rep(FALSE, length(append))
), fill = TRUE)

# remove some genc_ids with transfusions from site 2 to imitate drift
transf <- dbGetQuery(dbcon, "SELECT genc_id FROM transfusion WHERE hospital_id = 'LHSCU';") %>%
  data.table()
cohort[, excl := hospital_id == "LHSCU" & genc_id %in% transf$genc_id & as.numeric(substr(cohort$discharge_date_time, 9, 10)) < (month(discharge_date_time) + (year(discharge_date_time) - 2019) * 12) / 4]
cohort_new <- cohort[excl == FALSE, ]

coverage2 <- data_coverage(
  dbcon, cohort_new,
  table = c("transfusion"),
  plot_timeline = FALSE,
  plot_coverage = TRUE,
  custom_dates = custom_dates,
  hospital_label = "hosp"
)
coverage2[[2]]$hospital_id <- NULL
setnames(coverage2[[2]], "hosp", "hospital_num")
coverage2[[2]] <- coverage2[[2]][1:20]
coverage2[[2]] <- coverage2[[2]][order(discharge_month, hospital_num)]


##################################################
## customization

# add hospital_label
# add hospital_group

save(coverage, coverage2, file = "~GitHub/Rgemini/data/data_coverage.rda")

```
```{r eval = FALSE}
# Get encounters dischared since Apr 2017
admdad_subset <- admdad[discharge_date_time > "2017-04-01 00:00", ]

# Plot data timelines
coverage <- data_coverage(
  dbcon = db,
  cohort = admdad_subset,
  table = c("admdad", "lab", "ipscu"),
  plot_timeline = TRUE,
  plot_coverage = FALSE
)
```

```{r echo = FALSE, warning = FALSE}
load("../data/data_coverage.rda")
print(coverage$timeline_plot)
```

**Let's take a look at this plot. What do you notice?**

<details>
<summary>**Expand this section for some tips**</summary>

+ **Between-hospital differences in data timelines**
  + Looking at the timelines for `admdad`, you’ll notice that some hospitals generally have later start dates (e.g., hospital 1) and/or earlier end dates (e.g., hospitals 5 & 6) compared to others. The `additional_info` column in the `lookup_data_coverage` table may provide an explanation for some of these between-hospital differences in data timelines (e.g., see above, for hospital 1: “Hospital opened in February 2018.”). Depending on your research question, you may need to restrict your analyses to time periods that overlap across all sites / exclude sites with limited data timelines.
+ **Within-hospital differences in data timelines**
  + Even within the same hospital, data timelines can vary between tables. For example at sites 3 and 9, lab data have a shorter coverage period compared to `admdad`/`lab` data. This is typically due to challenges associated with extracting clinical (as opposed to administrative) data. If lab data are crucial for your research question, keep in mind that the effective data timeline for your analyses is determined by lab data coverage (rather than `admdad` coverage).
+ **Interrupted data timelines**
  + For some hospitals/tables, data timelines may be interrupted. For example, at site 8, lab data are not covered continuously. The `additional_info` column may contain some information that’s helpful for interpretation (e.g., “Hospital provides specialized care”). For example, it’s possible that lab testing is not performed on a routine basis at specialized hospitals and that the % of encounters with lab tests is generally very low even for time periods that are shown as “covered” in the timeline plot (remember that data coverage here is defined as at least 1 `genc_id` with an entry in the lab table in a 28-day period). In other words, the gaps in the data timeline might not necessarily reflect a data extraction issue, but rather could be an indicator of specialized clinical practice at this site. Therefore, it is important to inspect overall data volume for sites with interrupted data timelines and plot the % data coverage (see [plot_coverage](#plot_coverage) below). If lab data are crucial for your research question, you may consider exlcuding specialized hospitals with low lab data coverage/volume.
+ **Empty rows**
  + Some tables may not appear in the timeline plot at all for certain hospitals. For example, for site 6, the `ipscu` row is empty. According to the `additional_info` column in the `lookup_data_coverag`e table, this hospital does not have an ICU. This information can help us determine how to deal with this site in our analyses. For example, if we are simply looking at the ipscu table to determine if a `genc_id` was admitted to an ICU during their hospitalization, we can still include site 6 in our analyses and set `icu_entry` to `FALSE` for all encounters at site 6 (we know for a fact that patients were not admitted to an ICU while being hospitalized at site 6). By contrast, if we are planning to perform more in-depth analyses of `ipscu` data (e.g., analyses of lab tests performed in the ICU), site 6 would need to be excluded since it would not contribute any data to those analyses.
</details>


<br></br><br></br>

In addition to the plot, the function also returns a list object with several entries:

+ The 1st list item (`coverage_flag_enc`) contains the table with encounter-level flags based on `lookup_data_coverage` (also see section above):

```{r eval = FALSE}
coverage[[1]] # = coverage$coverage_flag_enc
```

```{r echo = FALSE, results = 'asis'}
cat("<div style='font-size: 10px;'>")
coverage[[1]][1:10] %>%
  knitr::kable(format = "html", escape = TRUE)
cat("</div>")
```

<br></br>

+ The 2nd list item (`timeline_data`) is the DB availability table with min-max dates per site & table (i.e., what’s shown in the data timeline plot)

```{r eval = FALSE}
coverage[[2]] # = coverage$timeline_data
```

```{r echo = FALSE, results = 'asis'}
cat("<div style='font-size: 10px;'>")
coverage[[2]][1:10] %>%
  knitr::kable(format = "html", escape = TRUE)
cat("</div>")
```

<br></br>

+ The 3rd list item (`timeline_plot`) is a ggplot object containing the timeline plot, which can be further customized/exported in the desired format. 

  For example, you could customize the title of the plot and move the legend position:

```{r}
coverage[[3]] + # = coverage$timeline_plot
  ggtitle("Data coverage exploration\n\n", subtitle = "GEMINI project XYZ") +
  theme(legend.position = "top")
```

<br></br><br></br>

## Plot % data coverage {#plot_coverage}

Finally, users can use the `plot_coverage` flag to plot the % of encounters with an entry in a given table, by hospital & discharge month. This provides more detailed insights into data coverage beyond the current threshold of 1 `genc_id` per 28 day period.

<strong style="color:red;">WARNING: </strong>
When plotting data coverage, your cohort input should only be pre-filtered for the hospitals and overall timelines of interest. You **should not** apply any other cohort inclusion/exclusion criteria (e.g., diagnosis codes etc.). This is to ensure that the coverage plots are representative of the overall GEMINI data holdings, and are not skewed by any project-specific cohort inclusion/exclusion steps.

Let's plot coverage for the transfusion table for our cohort discharged since April 2017: 

<br></br>

```{r eval = FALSE}
# Plot coverage (% genc_ids with entry in table)
coverage <- data_coverage(
  dbcon = db,
  cohort = admdad_subset,
  table = c("transfusion"),
  plot_timeline = FALSE,
  plot_coverage = TRUE
)
```

```{r echo = FALSE}
print(coverage2$coverage_plot$transfusion)
```

<br></br>

Users should carefully inspect these plots for unexpected patterns (e.g., sudden drops) and further inspect a) what’s driving these patterns, and b) how to handle time periods with low data coverage in their analyses. 

**Let's take a look at this plot. What do you notice?**

<details>
<summary>**Expand this section to learn more**</summary>

+ **Hospitals/time periods with no data coverage**
  + Some hospitals don’t have any transfusion data at all (e.g., sites 5 & 6) or don’t have any transfusion coverage during certain time periods (e.g., hospital 1/8/9).\* Note that time periods with 0% coverage could also be inferred from the timeline plot, which would have empty rows for any tables without any data coverage (see [`plot_timeline`](#plot_timeline)). However, the coverage plots provide more granular insights into coverage - beyond 0 vs. non-0 - allowing users to compare coverage between hospitals and over time on a continuous scale.
+ **Differences between hospitals**
  + For hospitals with transfusion data, we may see large differences in the % of encounters with an entry in the transfusion table (e.g., >15% at site 3 vs. <5% at site 8). This may not necessarily reflect differences in data coverage, but could be due to differences in clinical practice or medical subservices provided at different sites. As discussed above, we already know that site 8 provides specialized care. To check whether this might explain low transfusion rates, users could inspect the medical subservices provided at this site (e.g., `mrp_service` field in `admdad`) and could also check for potential differences in patient populations (e.g., most responsible diagnosis groups) at different sites. If transfusion data are crucial for the research question of interest, it may make sense to exclude hospitals with low transfusion data volume.
+ **Sudden drops in data coverage**
  + At hospital 7, we can see a large drop in the % transfusion coverage in the first quarter of 2019. Sudden, temporary drops like this typically reflect a data coverage issue (e.g., due to data extraction challenges, EHR transition etc.). Occassionally, these drops could also be due to temporary changes in clinical practice (e.g., COVID-19 waves, blood product shortages etc.) - although we would typically expect these changes to be more gradual and affect all hospitals. Depending on your research question, you may need to remove hospitals/time periods with low data coverage from your analyses, especially if you suspect a data coverage issue.
+ **Gradual changes in coverage over time**
  + At site 2, we can observe a gradual decrease in the % of encounters with a transfusion. This could be due to several different reasons:
    1) There may have been a change in clinical practice over time (e.g., new transfusion guidelines specific to this site)
    2) Changes in the patient cohort/medical subspecialties: It’s worth inspecting if patient characteristics remained constant over time, or whether there are reasons you’d expect transfusion rates to decrease over time (e.g., larger proportion of patients with no medical indication for a transfusion?)
    3) It’s possible that gradual changes in coverage are driven by data extraction issues. For example, later time periods may be missing transfusion entries for a certain subset of the GEMINI cohort (e.g., ICU patients). Hence, it could be worth plotting coverage for different patient cohorts separately (see cohort flags like `gim` or `all_med` in the `derived_variables` table).
    4) Finally, note that we are plotting data coverage by discharge month here (rather than transfusion month). This can potentially mask issues related to the extraction of transfusion products that were transfused during certain time periods. We therefore recommend plotting coverage by the relevant clinical date-time variable (i.e., issue_date_time for transfusions) in addition to the plots by discharge_date_time. Note that this is currently not supported by data_coverage() but can easily be achieved using Rgemini::plot_over_time() (e.g., time_var would be issue_date_time in the case of transfusions). This may show a more abrupt drop in data coverage and could indicate issues with data storage in the hospital’s EHR (e.g., system outage) rather than data extraction issues (which are typically related to discharge_date_time since GEMINI data are pulled by discharge date).

<br></br>

*\*As a side note: 0 in the coverage plot indicates that there were some encounters in the cohort during these time periods (i.e., `admdad` data are available), but none of the encounters had an entry in the `transfusion` table. By contrast, time periods that are not covered in the cohort/admdad table are shown as `NA` in these plots. For example, at site 1, we can see that the cohort only starts in February 2018 in line with the `additional_information` column stating that this hospital only opened in February 2018. between Feb 2018 - Jan 2020, GEMINI did not receive any transfusion data for the encounters from this site (% coverage = 0). Since January 2020, GEMINI has started receiving transfusion data with ~15-20% of encounters having an entry in the transfusion table at this site.
</details>


<br></br>


In addition to printing the coverage plot, the function will also return a list object similar to the one above:

1. `coverage_flag_enc`: Encounter-level data coverage flag
2. `coverage_data`: Table showing the % of encounters with a table entry by hospital & discharge month
3. `coverage_plot`: ggplot object containing coverage plot

Here is an example of the `coverage_data` table, which can be used to detect (and exclude) hospitals/months with low coverage. It also shows the number of encounters (`n_encounters`) that are in the denominator for each hospital * month combination based on the user-provided cohort input.

```{r eval = FALSE}
coverage[[2]] # = coverage$coverage_data
```

```{r echo = FALSE, results = 'asis'}
cat("<div style='font-size: 10px;'>")
coverage2[[2]][1:10] %>%
  knitr::kable(format = "html", escape = TRUE)
cat("</div>")
```

<br></br><br></br>

# Further customization

## `hospital_label` & `hospital_group`

## `custom_dates`

## `as_plotly`