---
title: "Plotting functions"
output:
  html_vignette:
    number_sections: true
    toc: true
    dfprint: kable

vignette: >
  %\VignetteIndexEntry{Plotting functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  include = TRUE, 
  eval = TRUE, 
  echo = TRUE, 
  results='asis', 
  warning = FALSE, 
  message = FALSE, 
  collapse = TRUE,
  cache = FALSE, 
  tidy = FALSE,
  fig.height = 3, 
  fig.width = 5
  
)


# remove all of these later...
library(Rgemini)
library(lubridate)
library(ggplot2)
library(ggpubr)
library(dplyr)
library(data.table)
library(lemon)
library(grid)
library(ggthemes)

library(sn)
library(MCMCpack)

source("H:/GitHub/Rgemini/R/plots.R") 
source("H:/GitHub/Rgemini/R/gemini_plot.R") 
source("H:/GitHub/Rgemini/R/gemini_theme.R")
source("H:/GitHub/Rgemini/R/dummy_data.R") 

options(knitr.kable.NA = '')

```

# Introduction

`Rgemini` contains several functions that facilitate common plotting needs and allow users to create customized figures with just a few lines of code. 


# Set-up

## Creating dummy data 

The plotting examples shown below are based on variables from the "ipadmdad" table. Typically, you would query this table from the GEMINI database, but for illustration purposes, let's create some dummy data using the `Rgemini` function `dummy_ipadmdad`. 

Here, we are simulating an "ipadmdad" table with 50,000 encounters from 9 different hospitals and with discharge dates ranging from fiscal years 2015 to 2022:

```{r}
set.seed(999)
ipadmdad <- dummy_ipadmdad(n = 50000, n_hospitals = 12, time_period = c(2015,2022)) %>%
  data.table()
```

```{r, echo=FALSE, results='asis'}
cat(paste0('Currently, this function only simulates a subset of variables in the "ipadmdad" table, namely: ', paste(colnames(ipadmdad), collapse = ", "), '.'))
```

*  *  *  *

# Histrograms 

First, let's use the `plot_histograms()` function to explore the dataset.

By default, the function will plot histograms of all relevant variables in the provided `data` input (ignoring `genc_id`, and any hospital/date-time variables). It will also show some basic descriptive stats about each variable at the top of the plot.

```{r, fig.height = 4, fig.width = 6}
plot_histograms(data = ipadmdad)
```

If you only want to plot a subset of variables, you can specify `plot_vars` as a character vector, for example:

```{r, eval = FALSE}
plot_histograms(ipadmdad, plot_vars = c("discharge_disposition", "number_of_alc_days"))
```
```{r}
## Note: This is equivalent to 
plot_histograms(ipadmdad[, .(discharge_disposition, number_of_alc_days)])
```

Note that in the example above, discharge disposition is treated as a numeric variable, even though it is in fact a categorical variable. Similarly, we might want to adjust the histogram for number of ALC days to only show data points up to 7 days. This can be done by providing the variables to be plotted as a `list`, which allows users to specify additional attributes, such as variable `class`. For numeric/integer variables, users can also control the `binwidth` and `breaks`, and whether or not to assume that the variable follows a `normal` distribution (in which case the descriptive statistics will show the mean [SD] instead of median [Q1, Q3]).

For example, we could specify that discharge disposition should be of class `character`, and that number of ALC days should be shown with `binwidth = 1` with `breaks` from 0-7 days. Additionally, for illustration purposes, let's say we want to get the mean [SD] of ALC days by specifying `normal = TRUE`. Finally, we can also control the titles shown above each figure based on the name of each list item (e.g., "# Days in ALC" instead of "Number of Alc Days"), and we can also remove the stats/bar labels by specifying `show_stats = FALSE`:

```{r}
plot_histograms(
  ipadmdad,
  plot_vars = list(
    `Discharge disposition` = list(plot_var = "discharge_disposition", class = "character"),
    `# Days in ALC` = list(plot_var = "number_of_alc_days", binwidth = 1, breaks = seq(0, 7, 1), normal = TRUE)
  ),
  show_stats = FALSE
)
```


*  *  *  *


# Plot variables by hospital & over time

Another common way to explore GEMINI data is to plot variables by individual hospitals over time. This can provide important insights into differences across sites and temporal trends. The `plot_hosp_time` function in `Rgemini` provides a simple way of creating different types of plots like that. 


## Default plot

By default, the `plot_hosp_time` function plots the mean of a user-specified `plot_var` (e.g., `age`) by hospital * month. For example:

```{r}
plot_hosp_time(
  cohort = ipadmdad,
  plot_var = "age"
)
```

Each line in the plot shown above represents the mean age at an individual hospital, and the thick line represents the mean age across all sites (note: hospitals with more encounters contribute more to this line than hospitals with fewer encounters).

There are several ways users can customize this plot by providing additional input arguments, which are explained in detail below. Briefly, users can provide the following input arguments:

- `func`: What function to use to aggregate data (e.g., median instead of mean, percentage for categorical variable, % missing etc.)
- `time_var`: Date-time variable of interest (default = `discharge_date_time`) 
- `time_int`: Time interval to aggregate data by (default = `month`, but could be `quarter`, `year`, `fisc_year`, `season`, or a custom time interval)
- `hosp_var`: Variable specifying hospital identifier (default = `"hospital_num"`)
- `hosp_group`: Optional hospital-level grouping variable (e.g., `"hospital_type"` or `"affiliation"`)
- `facet_var`: Optional variable to be used as `facet_wrap` (e.g., `facet_var = "hospital_num"` will plot individual subplots per hospital)
- `min_n`: Minimum number of data points required per hospital * time_int combination. Any cells with `n < min_n` will be suppressed.
- Plotting aesthetics like `line_width`, `ylabel`, `ylimits`, and `colors` 


## `func` 

Instead of plotting the average (`func = "mean"`), users can provide any of the following alternative `func` inputs:

- `"median"`
- `"%"` or `"perc"` to plot % of encounters in a specified category level. Users can specify `plot_cat` to indicate which category/factor level to plot (by default, the function will sort all unique values and plot the % in the highest category level). Note: For any character/logical/factor variables, the function will automatically infer `func = "%"`. 
- `"count"` or `"n"` to plot the number of rows/encounters


For example, to plot the number of encounters, simply specify `func = "n"` (no `plot_var` input needs to be provided in this case). Note that in this case, the thick "overall" line represents the median of all (individual hospital) lines, rather than the total count of rows across all sites.

```{r}
plot_hosp_time(
  cohort = ipadmdad,
  func = "n"
)
```


Or to plot the percentage of female encounters:

```{r}

plot_hosp_time(
  cohort = ipadmdad,
  plot_var = "gender",
  plot_cat = "F"
  #func = "%" # not required in this case because gender is a character variable, so the function infers that func should be "%"
)

```

When plotting percentages, any entries that are `NA` are automatically removed from both the numerator and denominator. 

Note that in the example of plotting `gender`, the function automatically infers `func = "%"` because `gender` is of class `character`.

If we wanted to plot `discharge_disposition`, which is of class `integer`, the function would by default plot the `"mean"`. However, in reality, discharge disposition represents a categorical variable, so we could run the following code to plot the percentage of encounters where `discharge_disposition %in% c(7, 72, 73, 74)` (i.e., % of hospitalizations that resulted in in-hospital death).

```{r}
plot_hosp_time(
  cohort = ipadmdad,
  plot_var = "discharge_disposition",
  func = "%",
  plot_cat = c(7, 72, 73, 74)
)
```


Finally, the function can also be used to plot the percentage of missing data by specifying `func = "na"` or `"missing"`, which plots the percentage of all entries that are either `NA`, `""`, or `" "`:

```{r}
plot_hosp_time(
  cohort = ipadmdad,
  plot_var = "alc_service_transfer_flag",
  func = "na"
)
```


## `time_var` and `time_int`

`time_var` specifies the variable containing the relevant date-time information. Typically, in GEMINI data, this is `"discharge_date_time"` since hospital data are pulled based on discharge dates. `time_int` specifies the time interval to use for aggregation (i.e., resolution along x-axis). By default, the function aggregates data by month, but users could also specify `"quarter"`, `"year"`, `"fisc_year"` (hospital fiscal year starting in April), or `"season"`.

For example, we could plot the number of encounters by quarter:

```{r}
plot_hosp_time(
  cohort = ipadmdad,
  func = "n",
  time_int = "quarter"
)
```

... or by fiscal year:

```{r}
plot_hosp_time(
  cohort = ipadmdad,
  func = "n",
  time_int = "fisc_year"
)
```


... or by season:

```{r}
plot_hosp_time(
  cohort = ipadmdad,
  func = "n",
  time_int = "season"
)
```



### Custom `time_int`

Note that users can in principle specify any custom time interval as long as this is provided as a column in the `cohort` input. For example, let's say we want to plot the number of encounters that were *admitted* to hospital each day in April 2020. Users can calculate the admission date prior to running the function and then provide it as the`time_int` input:

```{r}

ipadmdad[, my_date := as.Date(ymd_hm(admission_date_time))]

plot_hosp_time(
  cohort = ipadmdad[my_date >= "2020-04-01" & my_date <= "2020-04-30", ],
  func = "n",
  time_int = "my_date"
)
```





## View individual sites

If you want to inspect temporal trends at individual hospitals, there are 2 different approaches:

1) We could specify our hospital-level variable `hospital_num` as a `facet_var`, which will create individual subplots for each site. You could choose to plot/hide the overall line (mean age across all sites) by setting `show_overall` to either `TRUE` or `FALSE`:

```{r}
plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  time_var = "year",
  facet_var = "hospital_num",
  show_overall = TRUE
) 
```

2) The second option to highlight individual sites is to specify `hospital_num` as a `hosp_group`, which will add a legend for individual sites while still plotting all hospitals in a single plot: 

```{r}
plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  time_var = "year",
  hosp_group = "hospital_num"
)
```


## Grouping variables (color)

A more common application for the `hosp_group` is to add an additional layer of hospital-level grouping. For example, we may want to group hospitals into different types, such as academic vs. community hospitals. For illustration purposes, a random `hospital_type` is assigned to our dummy data and we can then add `hospital_type` as a `hosp_group`. The thick lines now represent the overall mean age at each hospital type. **Note that the data are aggregated across all encounters of each group level (e.g., the green line represents the mean age of all encounters at any large community site). This means that larger hospitals will contribute more to the average age than smaller hospitals.**

```{r}
# assign (random) hospital grouping variable
ipadmdad[, hospital_type := sample(c("Academic", "Community"), prob = c(.4, .6), 1, replace=TRUE), by = hospital_num] 

plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  time_var = "year",
  hosp_group = "hospital_type"
)
```
You could suppress the individual hospital lines in this plot by specifying `hosp_var = NULL`, and you can also change the plot colors as follows:

```{r}
plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  time_var = "year",
  hosp_var = NULL,
  hosp_group = "hospital_type",
  colors = c("#86b9b0", "#c266a7")
)
```

We could also apply `facet_var` here to show the individual hospitals in separate plots, with color coding reflecting the hospital type. For the purpose of this plot, we set `show_overall` to `FALSE` to avoid redundancy of information in each subplot:


```{r}
plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  time_var = "year",
  hosp_group = "hospital_type",
  facet_var = "hospital_num",
  colors = plot_colors[c(1, 3)],
  show_overall = FALSE,
)
```


One other alternative to illustrate differences between hospital types is to specify `hospital_type` as a `facet_var`. 

```{r}
plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  time_var = "year",
  hosp_group = "hospital_type",
  facet_var = "hospital_type",
  show_overall = TRUE
)
```
You can remove the grouping by color by specifying a single color value for the `colors` input, which will be applied to both facet plots: 

```{r}
plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  time_var = "year",
  hosp_group = "hospital_type",
  facet_var = "hospital_type",
  show_overall = TRUE,
  colors = "grey30"
)
```


## Encounter-level grouping variables

Note that the function always assumes that individual plot lines/subplot correspond to a hospital-level identifier and that `hosp_group` corresponds to a hospital-level grouping variable. If you want to apply any additional encounter-level grouping, this sould always be specified as a `facet_var` in order to make sure individual lines/color groupings still represent hospital-level variables. 

For example, we could plot `age` separately by `gender` by specifying `gender` as a `facet_var`:


```{r}
plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  time_var = "year",
  facet_var = "gender",
  show_overall = TRUE
)
```



*  *  *  *


## Plotting theme

All plots shown above apply a common theme specified in the function `Rgemini::gemini_theme()`. If you like the appearance of the plots shown above, you can apply this theme to any of your other figures you create, e.g.:

```{r}
my_plot <- ggplot(data = data.frame(group = c("A", "B"), mean = c(5, 7)), aes(x = group, y = mean)) +
  geom_bar(stat = "summary") +
  scale_y_continuous(name = "Mean", expand = c(0, 0))

my_plot + ggtitle("Original plot")

my_plot + gemini_theme() + ggtitle("Plot with GEMINI theme")
```




<!-- remove border around images -->
<style>
img {
border: 0;
}
</style>
