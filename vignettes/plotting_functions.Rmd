---
title: "Plotting functions"
output:
  html_vignette:
    number_sections: true
    toc: true
    dfprint: kable

vignette: >
  %\VignetteIndexEntry{Plotting functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  include = TRUE, 
  eval = TRUE, 
  echo = TRUE, 
  results = 'asis', 
  warning = TRUE, 
  message = FALSE, 
  collapse = TRUE,
  cache = FALSE, 
  tidy = FALSE,
  fig.height = 4, 
  fig.width = 6
  
)

# remove all of these later...
library(ggplot2)
library(ggpubr)
library(lemon)
library(grid)
library(ggthemes)

source("H:/GitHub/Rgemini/R/plots.R") 
source("H:/GitHub/Rgemini/R/utils.R") 

options(knitr.kable.NA = '')

```


*  *  *  *

# Introduction

`Rgemini` contains several functions that facilitate common plotting needs and allow users to create customized figures with just a few lines of code. 



*  *  *  *


# Set-up

## Creating dummy data 

The plotting examples shown below are based on variables from the "ipadmdad" table. Typically, you would query this table from the GEMINI database, but for illustration purposes, let's create some dummy data using the `Rgemini` function `dummy_ipadmdad`. 

Here, we are simulating an "ipadmdad" table with 50,000 encounters from 9 different hospitals and with discharge dates ranging from fiscal years 2018 to 2022:

```{r}
library(Rgemini)
library(dplyr)
library(data.table)

set.seed(999)
ipadmdad <- dummy_ipadmdad(n = 50000, n_hospitals = 12, time_period = c(2018, 2022)) %>%
  data.table()
```

```{r, echo=FALSE, results='asis'}
cat(paste0('Currently, this function only simulates a subset of variables in the "ipadmdad" table, namely: ', paste(colnames(ipadmdad), collapse = ", "), '.'))
```

*  *  *  *

# Histrograms 

First, let's use the `plot_histograms()` function to explore the dataset.

By default, the function will plot histograms of all relevant variables in the provided `data` input (ignoring `genc_id`, and any hospital/date-time variables). It will also show some basic descriptive stats about each variable at the top of the plot.

```{r, fig.height = 4, fig.width = 8}
plot_histograms(data = ipadmdad)
```

If you only want to plot a subset of variables, you can specify `plot_vars` as a character vector, for example:

```{r, eval = FALSE}
plot_histograms(ipadmdad, plot_vars = c("discharge_disposition", "number_of_alc_days"))
```
```{r}
## Note: This is equivalent to 
plot_histograms(ipadmdad[, .(discharge_disposition, number_of_alc_days)])
```

Note that in the example above, discharge disposition is treated as a numeric variable, even though it is in fact a categorical variable. Similarly, we might want to adjust the histogram for number of ALC days to only show data points up to 7 days. This can be done by providing the variables to be plotted as a `list`, which allows users to specify additional attributes, such as variable `class`. For numeric/integer variables, users can also control the `binwidth` and `breaks`, and whether or not to assume that the variable follows a `normal` distribution (in which case the descriptive statistics will show the mean [SD] instead of median [Q1, Q3]).

For example, we could specify that discharge disposition should be of class `character`, and that number of ALC days should be shown with `binwidth = 1` with `breaks` from 0-7 days. Additionally, for illustration purposes, let's say we want to get the mean [SD] of ALC days by specifying `normal = TRUE`. Finally, we can also control the titles shown above each figure based on the name of each list item (e.g., "# Days in ALC" instead of "Number of Alc Days"), and we can also remove the stats/bar labels by specifying `show_stats = FALSE`:

```{r}
plot_histograms(
  ipadmdad,
  plot_vars = list(
    `Discharge disposition` = list(plot_var = "discharge_disposition", class = "character"),
    `# Days in ALC` = list(plot_var = "number_of_alc_days", binwidth = 1, breaks = seq(0, 7, 1), normal = TRUE)
  ),
  show_stats = FALSE
)
```


*  *  *  *


# Plot variables by hospital & over time

Another common way to explore GEMINI data is to plot variables by individual hospitals over time. This can provide important insights into differences across sites and temporal trends. The `plot_hosp_time` function in `Rgemini` provides a simple way of creating different types of plots like that. 


## Default plot

By default, the `plot_hosp_time` function plots the mean of a user-specified `plot_var` (e.g., `age`) by hospital * month. For example:

```{r}
plot_hosp_time(
  cohort = ipadmdad,
  plot_var = "age"
)
```

Each line in the plot shown above represents the mean age at an individual hospital, and the thick line represents the mean age across all sites (note: hospitals with more encounters contribute more to this line than hospitals with fewer encounters).

There are several ways users can customize this plot by providing additional input arguments, which are explained in detail below. Briefly, users can provide the following input arguments:

- `func`: What function to use to aggregate data (e.g., median instead of mean, percentage for categorical variable, % missing etc.)
- `time_var`: Date-time variable of interest (default = `discharge_date_time`) 
- `time_int`: Time interval to aggregate data by (default = `month`, but could be `quarter`, `year`, `fisc_year`, `season`, or a custom time interval)
- `hosp_var`: Variable specifying hospital identifier (default = `"hospital_num"`)
- `hosp_group`: Optional hospital-level grouping variable (e.g., `"hospital_type"` or `"affiliation"`)
- `facet_var`: Optional variable to be used as `facet_wrap` (e.g., `facet_var = "hospital_num"` will plot individual subplots per hospital)
- `min_n`: Minimum number of data points required per hospital * time point combination. Any cells with `n < min_n` will be suppressed.
- Plotting aesthetics like `line_width`, `ylabel`, `ylimits`, and `colors`(see function documentation for more details)


## `func` 

Instead of plotting the average (`func = "mean"`), users can provide any of the following alternative `func` inputs:

- `"median"`
- `"%"` or `"prct"`/`"perc"` to plot % of encounters in a specified category level. Users can specify `plot_cat` to indicate which category/factor level to plot (by default, the function will sort all unique values and plot the % in the highest category level). Note: For any character/logical/factor variables, the function will automatically infer `func = "%"`. 
- `"count"` or `"n"` to plot the number of rows/encounters


For example, to plot the number of encounters, simply specify `func = "n"` (no `plot_var` input needs to be provided in this case). Note that in this case, the thick "overall" line represents the median of all (individual hospital) lines, rather than the total count of rows across all sites.

```{r}
plot_hosp_time(
  cohort = ipadmdad,
  func = "n"
)
```


Or to plot the percentage of female encounters:

```{r}

plot_hosp_time(
  cohort = ipadmdad,
  plot_var = "gender",
  plot_cat = "F"
  #func = "%" # not required in this case because gender is a character variable, so the function infers that func should be "%"
)

```

When plotting percentages, any entries that are `NA` are automatically removed from both the numerator and denominator. 

Note that in the example of plotting `gender`, the function automatically infers `func = "%"` because `gender` is of class `character`.

If we wanted to plot `discharge_disposition`, which is of class `integer`, the function would by default plot the `"mean"`. However, in reality, discharge disposition represents a categorical variable, so we could run the following code to plot the percentage of encounters where `discharge_disposition %in% c(7, 72, 73, 74)` (i.e., % of hospitalizations that resulted in in-hospital death).

```{r}
plot_hosp_time(
  cohort = ipadmdad,
  plot_var = "discharge_disposition",
  func = "%",
  plot_cat = c(7, 72, 73, 74)
)
```


Finally, the function can also be used to plot the percentage of missing data by specifying `func = "na"` or `"missing"`, which plots the percentage of all entries that are either `NA`, `""`, or `" "`. Let's plot the % of encounters with missing ALC flag and rename the ylabel to `"% Missing ALC"`:

```{r}
plot_hosp_time(
  cohort = ipadmdad,
  plot_var = "alc_service_transfer_flag",
  func = "na"
) + labs(y = "% Missing ALC flag")
```


## `time_var` and `time_int`

`time_var` specifies the variable containing the relevant date-time information. Typically, in GEMINI data, this is `"discharge_date_time"` since hospital data are pulled based on discharge dates. `time_int` specifies the time interval to use for aggregation (i.e., resolution along x-axis). By default, the function aggregates data by month, but users could also specify `"quarter"`, `"year"`, `"fisc_year"` (hospital fiscal year starting in April), or `"season"`.

For example, we could plot the number of encounters that were discharged (default) each fiscal year:

```{r}

plot_hosp_time(
  cohort = ipadmdad,
  func = "n",
  #time_var = "discharge_date_time", # default
  time_int = "fisc_year"
)
```

... or the number of encounters that were admitted each season:

```{r}
plot_hosp_time(
  cohort = ipadmdad,
  func = "n",
  time_var = "admission_date_time",
  time_int = "season"
)
```



### Custom `time_int`

Note that users can in principle specify any custom time interval as long as this is provided as a column in the `cohort` input. For example, let's say we want to plot the number of encounters that were *admitted* to hospital each day in April 2020. Users can calculate the admission date prior to running the function and then provide it as the`time_int` input:

```{r}
library(lubridate)
ipadmdad[, my_date := as.Date(ymd_hm(admission_date_time))]

plot_hosp_time(
  cohort = ipadmdad[my_date >= "2020-04-01" & my_date <= "2020-04-30", ],
  func = "n",
  time_int = "my_date"
)
```



## View individual hospitals

If you want to inspect temporal trends at individual hospitals, there are 2 different approaches:

1) You could specify our hospital-level variable `hospital_num` as a `facet_var`, which will create individual subplots for each site. You could choose to plot/hide the overall line (mean age across all sites) by setting `show_overall` to either `TRUE` or `FALSE`:

```{r fig.height = 7, fig.width = 9}
plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  facet_var = "hospital_num",
  show_overall = TRUE
) 
```

2) The second option to highlight individual sites is to specify `hospital_num` as a `hosp_group`, which will add a legend for individual sites while still plotting all hospitals in a single plot: 

```{r}
plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  hosp_group = "hospital_num"
)
```


## Grouping variables (color)

A more common application for the `hosp_group` is to add an additional layer of hospital-level grouping. For example, you may want to group hospitals into different types, such as academic vs. community hospitals. For illustration purposes, a random `hospital_type` is assigned to our dummy data and we can then add `hospital_type` as a `hosp_group` varible. The thick lines now represent the overall mean age at each hospital type. Note that the data are aggregated across all encounters of each group level (e.g., the cyan line represents the mean age of all encounters at any community site). This means that larger hospitals will contribute more to the average age than smaller hospitals.

```{r}
# assign (random) hospital grouping variable
ipadmdad[, hospital_type := sample(
  c("Academic", "Community"), prob = c(.4, .6), 1, replace = TRUE
), by = hospital_num] 

plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  hosp_group = "hospital_type"
)
```
You could suppress the individual hospital lines in this plot by specifying `hosp_var = NULL`, and you can also change the plot colors as follows:

```{r}
plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  hosp_var = NULL,
  hosp_group = "hospital_type",
  colors = c("#86b9b0", "#c266a7")
)
```

We could also apply `facet_var` here to show the individual hospitals in separate plots, with color coding reflecting the hospital type. For the purpose of this plot, we set `show_overall` to `FALSE` to avoid redundancy of information in each subplot:


```{r fig.height = 7, fig.width = 9}
plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  hosp_group = "hospital_type",
  facet_var = "hospital_num",
  show_overall = FALSE
)
```


One other alternative to illustrate differences between hospital types is to specify `hospital_type` as a `facet_var`. 

```{r}
plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  facet_var = "hospital_type",
  show_overall = TRUE
)
```


## Encounter-level grouping variables

Note that the function always assumes that individual plot lines (or subplots) correspond to a **hospital-level** identifier and that `hosp_group` corresponds to a **hospital-level** grouping variable. If you want to apply any additional encounter-level grouping, this should always be specified as a `facet_var` in order to make sure individual lines/color groupings still represent hospital-level variables. 

For example, we could plot `age` separately by `gender` by specifying `gender` as a `facet_var`. Since there are not many encounters with gender = `"O"`, we may want to apply cell suppression to any data points with n < 6 by specifying `min_n = 6`. In our sample data, there is no cell with `gender == "O"` that has at least 6 data points, so no figure for gender = `"0"` is shown at all here:

```{r fig.width = 9}
plot_hosp_time(
  ipadmdad,
  plot_var = "age",
  facet_var = "gender",
  show_overall = TRUE,
  min_n = 6
)

# plot_hosp_time(
#   ipadmdad,
#   plot_var = "age",
#   hosp_var = "gender",
#   hosp_group = "gender",
#   time_int = "year",
#   facet_var = "hospital_num",
#   show_overall = TRUE,
#   min_n = 20
# )

```

## Returning aggregated data

There might be situations where users want the function to return the aggregated data, instead of plotting the results. This could be useful for debugging purposes, checking for outliers, or to further process the data before plotting the results. This can easily be achieved by specifying `return_data = TRUE`:

```{r}
res <- plot_hosp_time(
  ipadmdad,
  hosp_group = "hospital_type",
  func = "median",
  plot_var = "age",
  return_data = TRUE
)
```

This will return a list of 2 `data.table` objects, where the 1st entry corresponds to the results aggregated by individual hospitals * time interval (e.g., `hospital_num` * `month` by default):

```{r}
knitr::kable(head(res[[1]]))
```


The 2nd list entry corresponds to the overall results (see thick line in plots above), i.e., data aggregated by time and grouping variable (if any), such as `hospital_type` in this example:
```{r}
knitr::kable(head(res[[2]]))
```

In both tables, `n` corresponds to the number of data points in each cell.


*  *  *  *


# Plotting theme

All plots shown above apply a common theme specified in the function `Rgemini::gemini_theme()`. If you like the appearance of the plots shown above, you can apply this theme to any other `ggplots` you create. `Rgemini` also contains a color palette called `gemini_colors` that you can use, e.g.:

```{r}
my_plot <- ggplot(data = data.frame(group = c("A", "B"), mean = c(5, 7)), aes(x = group, y = mean)) +
  geom_bar(stat = "summary", fill = gemini_colors[1]) +
  scale_y_continuous(name = "Mean", expand = c(0, 0))

my_plot + ggtitle("Original plot")

my_plot + 
  scale_color_manual(values = gemini_colors) +
  gemini_theme() + 
  ggtitle("Plot with GEMINI theme")

```




<!-- remove border around images -->
<style>
img {
border: 0;
}
</style>
